#lang racket

(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))

(test 0 (p))

; При нормальном порядке вычисления программа вернёт 0, потому что не станет вычислять значение "p" до тех пор,
; пока оно ей не понадобится, а мы в данном случае никогда не провалимся в ветку else. При аппликативном порядке
; программа будет выполняться бесконечно, потому что "y" определен рекурсивно, а при вычислении программа будет пытаться
; подставить значение "y".
